---
title: 'OCS2024: Exploring the genome - an overview of tools and applications for the modern Chondrichthyes ecologist'
author: "Floriaan Devloo-Delva"
date: "April 2024"
format: 
  html:
    theme: cosmo
    keep-tex: true
    toc: true
    toc_depth: 3
    toc_float: yes
    toc-location: left
    number-sections: true
editor: visual
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(knitr)
library(formatR)
library(tidyverse)

knitr::opts_chunk$set(tidy = TRUE, tidy.opts = list(width.cutoff = 72),
                      cache = TRUE,
                      echo = TRUE)
```

# Setting up R environments

## Getting set up

To begin, you should download and install R from the CRAN. This is the online hub for the R language and it stands for Comprehensive R Archive Network. Be sure to download the correct R installation for your operating system.

[Dowload R here](https://cran.r-project.org/bin/)

We also strongly recommend you install RStudio, a front-end for R. This utility makes working in the R environment a lot more straightforward, standardises things across operating systems and has many helpful features. For the purposes of these tutorials, we will assume you are using RStudio.

[Dowload Rstudio here](https://posit.co/download/rstudio-desktop/)

With both R and RStudio installed, start Rstudio and we will begin!

**For this tutorial I use R version 4.2 and Rstudio version 2023.09.1, but newer versions work as well.**

## Install packages

If you have trouble installing packages try to "restart R" under "Session".


```{r, eval=FALSE}
install.packages("dartRverse")
install.packages("adegenet")
install.packages("directlabel") #needed for PCA
install.packages("networkD3") #needed for private allele analysis
install.packages("related_1.0.tar.gz", 
                 repos = NULL) # Needs to be located in you working directory
install.packages("devtools")
devtools::install_github("kkeenan02/diveRsity")

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("snpStats", force = TRUE,update = FALSE) #for LD

devtools::install_github('mijangos81/ggtern') # for HWE diagnostics
devtools::install_github('green-striped-gecko/dartR.popgen')

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("qvalue")
```

## Load packages

```{r, warning=FALSE, message=FALSE}
library(dartRverse)
library(dartR.popgen)
library(adegenet)
library(diveRsity)
library(snpStats) #only for LD
library(ggtern) # for HWE diagnostics
library(related)
```

# Data introduction

We have made three dataset available for this tutorial. **Pick one:**

1.  Bull shark DArTcap data

2.  Northern River shark DArTcap data

3.  Blue Shark DArTseq data

## Bull shark

Data from Devloo-Delva et al. (2023a).

![The Bull Shark](images/Bull_Shark.jpg)

```{r, eval=FALSE}
data.file <- "data/Bull_shark_DArTcap_1rowGT.csv"
metadata.file <- "data/Bull_shark_DArTcap_metadata.csv"
```

## Northern River shark

Data from Feutry et al. (2020).

Around 470 *G. garricki* samples were collected from 11 different sampling locations in Northern Australia and Papua New Guinea.

![The Northern River shark](images/Northern_River_Shark.jpg)

```{r}
data.file <- "data/Northern_river_shark_DArTcap_1rowGT.csv"
metadata.file <- "data/Northern_river_shark_DArTcap_metadata.csv"
```

## Blue shark

Data from Nikolic et al. (2023).

![The Blue Shark](images/Blue_shark.jpg)

```{r, eval=FALSE}
data.file <- "data/Blue_shark_DArTSeq_1rowGT_subset.csv"
metadata.file <- "data/Blue_shark_DArTseq_metadata.csv"
```

# Pre-dartR Filtering

**Diversity Arrays Technology**

Sequences generated by Diversity Arrays Technology (DArT) are processed using proprietary analytical pipelines before the report (containing the SNP and SilicoDArT markers) is provided to the client and the data are passed to dartR.\

1.  Poor quality sequences are first filtered (minimum barcode Phred score 30, pass percentage 75; minimum whole-read Phred score 10, pass percentage 50). In that way, assignment of the sequences to specific samples in the sample disaggregation step is very reliable.\

2.  These sequences are truncated to 69 bp and aggregated into clusters by the DArT fast clustering algorithm.\

3.  The sequences are then error-corrected. Identical sequences are then collapsed. These error-corrected sequences are analysed using DART software (DArT GS14 pipeline) to output candidate SNP markers.\

4.  As an additional quality control, a selection of samples (30 to 100% of samples) is processed twice. These are technical replicates. Scoring consistency (reproducibility or more strictly, repeatability) is used as the main selection criterion for high quality/low error rate markers.

Package `dartR` picks up the analysis at this point. The additional filtering that you may choose to undertake using dartR depends upon the research questions and other considerations as outlined below.

# Reading and filtering raw data

For the purpose of this markdown we will use the `dartR` package to read and filter the data.

![](images/dartR7.png)

## Import data

```{r}
data.gl <- dartR.base::gl.read.dart(filename = data.file,
                                ind.metafile = metadata.file, 
                                verbose = 1)
```

## Save raw data

```{r, eval=FALSE}
save(data.gl, file = "data/raw_genlight.Rdata")
```

## Quality filtering

The order of filtering can be important and requires some thought. The filtering steps may change depending on the analysis you intend to run. There is no one-fits-all approach to SNP filtering.

::: {.callout-warning}
## CAUTION

Be careful not to over-filter. The objective is to get an appropriate balance between signal to noise ratio, not to eliminate noise altogether at the expense of also taking out some signal. This balance will depend on downstream application.

*A good strategy is to undertake an exploratory analysis first, whereby you experiment with filtering. Perhaps start with very stringent filtering, examine the impact on the final analysis, then progressively reduce the stringency to select the minimal filtering regime that still delivers a stable outcome. Play with your data to get a feel for the balance between signal to noise ratio, in the context of the analyses you propose to subsequently undertake.*
:::

### Average reproducibility

DArT includes several technical replicates (\~30 %) of your samples to see how reproducible the results are. Some SNPs are less reliable than others.

*This metric is based on all individuals in your original dataset.*

**It is not advised to filter on reproducibility \> 0.99, since you are like to remove more heterozygous SNPs (i.e. more difficult to genotype consistently).**

:::{.panel-tabset}
```{r}
dartR.base::gl.report.reproducibility(data.gl, verbose = 1)
data.gl <- dartR.base::gl.filter.reproducibility(data.gl, threshold = 0.98, 
                                                 plot.colors = c("#2171B5", "#6BAED6"),
                                                 verbose = 1)
```
:::
### Invariable sites

You want to remove SNP that are not informative for population-level analyses. This will improve computation time and reduce the noise in the data.

#### All NA

Removes SNPs that have missing data for all samples.

```{r}
data.gl <- dartR.base::gl.filter.allna(data.gl, verbose = 1)
```

#### Monomorphic

Looks for loci which are all 0 (or 1 or 2) over the all samples. These are not informative.

```{r}
dartR.base::gl.report.monomorphs(data.gl, verbose = 1)
data.gl <- dartR.base::gl.filter.monomorphs(data.gl, verbose = 5)
```

#### Minor Allele Frequency

Some mutations only occur in a couple of individuals, these are not informative for population-level analyses. Loci with a low Minor Allele Frequency (MAF) might not be informative enough and just increase computation time.

::: {.callout-warning}
## CAUTION

The threshold should be lower than the proportion of your smallest sampling location. For example, if one of your sample sites has 5 samples out of a total of 100 samples, the MAF should not be \< 0.05. Else, your risk loosing the informative markers that differntiate that population.
:::

```{r}
dartR.base::gl.report.maf(data.gl, verbose = 1)
data.gl <- dartR.base::gl.filter.maf(data.gl, threshold = 0.005, 
                                     plot.colors = c("#2171B5", "#6BAED6"),
                                     verbose = 1)
```

### Read depth

Read depth has a considerable influence on the veracity of SNP calls. The low values arise because of chance variation in the coverage of particular bases. The high values arise because of the differential efficiency of the PCR steps or paralogous fragments. Under some circumstances, it might be sensible to push the lower threshold for read depth higher than has been used by the Diversity Arrays Technology in their report. Analyses that rely heavily on the accuracy of calls of heterozygotes may require a higher threshold for read depth, say 10x, for example.

**Check the histogram to see how many SNP have low or high counts. Low counts might not be reliably genotyped. High counts may be due to paralogous fragments.**

```{r}
dartR.base::gl.report.rdepth(data.gl, verbose = 1)
data.gl <- dartR.base::gl.filter.rdepth(data.gl, lower = 5, upper = 200, verbose = 1)
```

### Missing data for SNPs

Call rate is defined as `1 - proportion of missing data`. SNPs with too much missing data are not reliable and informative.

Call Rate for SNPs can arise from two sources. The first source is where a missing value arises because the sequence tag bearing the target SNP cannot be amplified -- there has been a mutation at one or both of the restriction sites. The second source of missing values is where the read depth is insufficient to make a reliable call on the SNP. Either way, the SNP is not called and is recorded as NA. A first step in filtering on Call Rate is to examine the distribution of Call Rates across loci. We use the function `gl.report.callrate` to yield the following output and graph.

```{r}
dartR.base::gl.report.callrate(data.gl, method = "loc", verbose = 1)
data.gl <- dartR.base::gl.filter.callrate(data.gl, method = "loc",  threshold = 0.8, verbose = 1)
```

### Missing data for individuals

Call rate is defined as `1 - proportion of missing data`. Samples with degraded DNA will have a lot of missing sequencing data. These samples are unreliably sequenced and should be removed.

```{r}
dartR.base::gl.report.callrate(data.gl, method = "ind", verbose = 1)
data.gl <- dartR.base::gl.filter.callrate(data.gl, method = "ind", threshold = 0.8, verbose = 1)
```

### Individual heterozygosity

Delete individuals with a heterozygosity below or above the threshold. High heterozygosity could be due to DNA cross-contamination from other individuals. Low heterozygosity could be due to population structure, inbreeding or excess missing values (normally the latter should be filtered out already).

```{r}
dartR.base::gl.report.heterozygosity(data.gl, method = "ind", verbose = 1)
data.gl <- dartR.base::gl.filter.heterozygosity(data.gl, t.lower = 0, t.upper = 0.2,  verbose = 1)
```

### Invariable sites

When filtering has resulted in removal of some individuals or populations, variation at several loci may be lost. Some loci may even be scored as missing across all individuals. You may wish to remove these monomorphic loci from your dataset.

```{r}
data.gl <- dartR.base::gl.filter.allna(data.gl, verbose = 1)
dartR.base::gl.report.monomorphs(data.gl, verbose = 1)
data.gl <- dartR.base::gl.filter.monomorphs(data.gl, verbose = 1)
```

### Linked loci

SNPs that are close together will be inherited together. Consequently, linked SNPs are not independent and will bias the data by inflating the signal.

::: {.callout-tip}
## NOTE

Do not filter on LD, if you aim to analyse you data of effective population size based on linkage disequilibrium.
:::

#### Short-distance linkage

Sequence tags can contain more than one callable SNP marker. Because of their close proximity, these multiple SNPs within a single sequence tag (referred to in dartR as 'secondaries' are likely to be strongly linked (inherited together). This is problematic for many analyses, so one might wish to filter out the multiple SNPs to leave only one per sequence tag.

This function removes SNPs on the same 70 bp sequence tag, it retains the SNP with the highest RepAvg (average reproducibility) andrAvgPIC (average polymorphic information content), respectively.

```{r}
dartR.base::gl.report.secondaries(data.gl, verbose = 1)
data.gl <- dartR.base::gl.filter.secondaries(data.gl, method = "best", verbose = 1)
```

#### Long-distance linkage

**Not running this because it takes too long, but consider using this if you have many SNPs and a small genome.**

```{r, eval=FALSE}
ld.report <- dartR.base::gl.report.ld.map(data.gl, ld.stat = "R.squared", verbose = 1)
ld.report$ld_stat <- ld.report$ld.stat
ld.report$locus_a.stat_keep <- ld.report$locus_a.stat.keep
ld.report$locus_b.stat_keep <- ld.report$locus_b.stat.keep
dartR.base::gl.report.ld(data.gl, verbose = 1)
data.gl <- dartR.base::gl.filter.ld(data.gl, ld.report, threshold = 0.25, verbose = 1)
```

### Hardy-Weinberg equilibrium

The Hardy--Weinberg equilibrium (HWE) states that allele and genotype frequencies in a population will remain constant from generation to generation in the absence of other evolutionary influences. SNPs that are sampled from a population in demographic equilibrium are expected to follow this equation: $p^2 + 2pq + q^2 = 1$, where $p$ is the frequency of the major allele (A) and $q$ is frequency of the minor allele (a).

In the simplest case of a single locus with two alleles denoted A and a with frequencies $f(A) = p$ and $f(a) = q$, respectively, the expected genotype frequencies under random mating are $f(AA) = p^2$ for the AA homozygotes, $f(aa) = q^2$ for the aa homozygotes, and $f(Aa) = 2pq$ for the heterozygotes.

::: {.callout-warning}
## NOTE!

There are several factors that can cause deviations from Hardy-Weinberg proportions including:

* Mutations
* Finite population size
* Selection
* Population structure
* Age structure
* Assortative mating
* Sex linkage
* Non-random sampling
* Genotyping errors

Therefore, testing for Hardy-Weinberg proportions should be a process that involves a careful evaluation of the results, a good place to start is Waples (2015). Note that tests for H-W proportions are only valid if there is no population substructure (assuming random mating) and have sufficient power only when there is sufficient sample size (n individuals \> 15).
:::

```{r}
dartR.base::gl.diagnostics.hwe(data.gl, verbose = 1)
dartR.base::gl.report.hwe(data.gl, verbose = 1)
data.gl <- dartR.base::gl.filter.hwe(data.gl, n.pop.threshold = 3, 
                                     mult.comp.adj = TRUE, 
                                     mult.comp.adj.method = "BH", 
                                     verbose = 1)
```

### Remove duplicate individuals

```{r}
res_dup <- dartR.base::gl.report.replicates(data.gl,loc_threshold = 500, perc_geno = 0.85)
```

## Filtering Conclusion

**Influence of Planned Analyses**

Possibly the most influential consideration on filtering is the purpose for which the filtered data set is to be used.

-   If you are planning to generate ***high resolution linkage maps***, then highly stringent filtering is warranted, and Diversity Arrays Technology would adjust their pipelines accordingly upon request. Similarly, if you are contemplating an analysis of ***relatedness or inbreeding***, then stringent filtering might be warranted. In any case, it would be wise to start out with high stringency and then progressively relax the stringency and examine the impact on outcomes.

-   If your focus is on identifying ***sex linked markers***, which rely heavily on identifying markers that are heterozygous in XY individuals and homozygous in XX individuals, then a filtering threshold for read depth of 10x would be sensible. Sequencing volume in the context of genome size will provide an upper limit to how far you can push the read depth threshold, so in some cases, a high sequence volume service will need to be requested. Because the pipelines of Diversity Arrays Technology depend in part on Mendelian behaviour in the selection of SNP markers, and sex-linked loci do not behave in Mendelian fashion, you might also ask them to relax the stringency of some aspects of their filtering in generating the report.

-   If your focus is on ***Genome-wide Association Studies (GWAS)*** or identifying ***loci under selection***, then noise in the data will not associate with phenotype, and so filtering can be less stringent in order to maximize the chances of identifying promising associations.

-   ***Principal Coordinates Analysis*** PCA (and to a lesser extent, ***Principal Components Analysis***, PCoA), rely on fully populated data matrices (no missing values). Classical PCA for example, cannot easily accommodate missing values. To overcome this, a balance must be struck between filtering on Call Rate and imputing the values of those missing values that remain. More stringent filtering on Call Rate, and less imputation; but more stringent filtering on Call Rate, more loss of potentially useful information or valuable samples. Refer to Georges et al. (2023, BioxRiv <https://doi.org/10.1101/2023.03.22.533737>) for further discussion of this point.

::: {.callout-tip}
## IMPORTANT!

There is no hard and fast rule to guide decisions on filtering SNP datasets prior to a substantive analysis. The decisions are based on comparing the distribution of the parameters to be filtered (using one of the gl.report functions) and the purpose to which the filtered dataset is to be put. Sequencing volume can constrain options, and the likelihood of some level of contamination of samples or presence of inhibitors of the restriction enzymes can have a bearing on the decisions. It is important not to over filter because of the risk of introducing a level of systematic bias and because of the unnecessary loss of informative loci or individuals. An experimental approach is recommended, whereby different filtering regimes are tried (from stringent to less stringent) and checked for influence on analysis outcomes.
:::

# Population structure

Inferring ancestry differences among individuals from different populations, or identifying population structure has been motivated by many applications:

-   Population genetics

-   Genetic association studies

-   Prediction of whether an individual will have particular traits (for instance in people that have the duffy antigen that allows them to have resistance to malaria)

Until recently we were only able to group individuals into populations using a few genetic markers. However, the decrease in cost and improvements in technology mean that is now feasible to use whole genomes to perform these kinds of analyses. This means that we can now have very fine scaled analyses of populations based on many thousands of markers.

Examining population structure can give us a great deal of insight into the history and origin of populations. Model-free methods for examining population structure and ancestry, such as ***principal components analysis*** are extremely popular in population genomic research. This is because it is typically simple to apply and relatively easy to interpret.

## Principal Component Analysis

Principal components analysis (PCA) is the most commonly recognised and used method for identifying population structure. Essentially, PCA aims to identify the main axes of variation in a dataset with each axis being independent of the next (i.e. there should be no correlation between them). The first component summarizes the major axis variation and the second the next largest and so on, until cumulatively all the available variation is explained. In the context of genetic data, PCA summarizes the major axes of variation in allele frequencies and then produces the coordinates of individuals along these axes. For the rest of the tutorial we will conduct a PCA to demonstrate how it can help give insight to population structure within species.

This analysis allows us to calculate principal components (PCs) that explain the differences between individuals in genetic data. The naming of each of these components is based on the percentage of variation in the data they explain, with principal component 1 (PC1) being the most explanatory PC of the data. For instance if PC1 explains 5.7%. PC2 will have the next largest contribution to the genetic variance, for example PC2 may contribute 3.4%. The overall variance should add up to 100%.

```{r}
PCA <- dartR.base::gl.pcoa(data.gl, nfactors = 5, verbose = 0)
dartR.base::gl.pcoa.plot(PCA, data.gl, xaxis = 1, yaxis = 2, verbose = 0)
dartR.base::gl.pcoa.plot(PCA, data.gl, xaxis = 2, yaxis = 3, verbose = 0)
```

::: {.callout-note}
## Exercise

![](images/task.png){#id .class width="48" height="48"}

  * How many genetic clusters are present across the sequenced samples? A cluster can be defined as a group of individuals that are genetically very similar to each other. Each cluster is genetically distinct from other clusters.

  * What is the relationship among these genetic clusters? i.e. which cluster is the most genetically distinct? Which genetic clusters are most similar to one another?

  * How many PCs is it worth plotting?

  * Can you identify the cluster membership of each individual? There are a variety of ways to do this. For example, you can look at the `PCA$scores` and sort the columns by PC.
:::

## Fixation indices

$FST$, also known as the fixation index, is an extremely important statistic in population genetics, molecular ecology and evolutionary biology. It is also arguably one of the most famous population genetic statistics you will encounter. $FST$ essentially measures the level of genetic differentiation between two or more populations. It ranges from 0 (i.e. no genetic differentiation) to 1 (complete genetic differentiation)

Ultimately, it is quite a simple statistic to understand but it can sometimes take time to properly grasp. So we will go over the basics properly here. One of the most confusing things about $FST$ is that are several different ways to define it. For ease of understanding, we will use a simple formulation:

$FST=(HT−HS)/HT$

For simplicity, imagine we are examining two populations only. With this formulate, $HT$ is the expected heterozygosity when the two populations are considered as one large meta-population. $HS$ is the average expected heterozygosity in the two populations.

You might be thinking, hang on a minute... what do we mean by expected heterozygosity? To appreciate this, we need to think back to the Hardy-Weinberg expectation we learned about in Section 4.3.9. Remember that at a simple bi-allelic locus, $p$ and $q$ are the frequencies of the two alleles. We can calculate the expected frequency of heterozygotes with $2pq$ - this is the expected heterozygosity.

You can use $FST$ to identify the relationship between individuals, and it can be used to identify populations. To do this, you first need to define the members of each of your populations. You did this at the end of the PCA section where you identified cluster membership.

```{r, warning=FALSE}
fst.res <- dartR.base::gl.fst.pop(data.gl, nboots = 100, verbose = 0)
fst.res$Fsts
fst.res$Pvalues
## correction for multiple testing: Bonferroni, Benjamini-Hochberg
Fst.p.adj <- stats::p.adjust(fst.res$Pvalues, "BH")
Fst.p.adj <- matrix(Fst.p.adj, ncol = adegenet::nPop(data.gl))
colnames(Fst.p.adj) <- adegenet::popNames(data.gl)
rownames(Fst.p.adj) <- adegenet::popNames(data.gl)
Fst.p.adj

fixed.diff <- dartR.base::gl.fixed.diff(data.gl, tloc = 0.1, verbose = 0)
fixed.diff$fd
```

::: {.callout-note}
## Exercise

![](images/task.png){.class width="48" height="48"}

  * Do the $FST$ metrics support the PCA results?

  * Do you see a different significance in p-values when correcting for multiple comparisons?
:::

# Genetic diversity

Genetic variability of populations of a species is important because it can be thought of an indirect measure of the evolvability of those populations. The greater the genetic diversity of a population the bigger the amount of genetic raw material upon which selection can act. A population deprived of its genetic variability is less likely to respond to environmental changes and more vulnerable to the negative effects of inbreeding. From a theoretical point of you measuring (correctly) genetic diversity of a population and comparing it among different naturally occurring or human driven treatments might be important to test the theoretical predictions on impact of drift on effect of population size of relatively isolated (small) populations and on mechanisms of genetic variance (diversity) maintenance. From the conservation point of view the relative genetic diversity of population differentially affected by human intervention might give insight into how resilient populations of a species are to rapid changes of the habitat in which they live.

Ho Hs Ht Dst Htp Dstp Fst Fstp Fis Dest Gst_max Gst_H

For all indexes, the entropies (H) and  Hill numbers (D) are calculated. In a nutshell, the alpha indexes between the different q-values should be similar if there is no deviation from expected allele frequencies and occurrences (e.g. all loci in HWE & equilibrium). If there is a deviation of an index, this links to a process causing it, such as dispersal, selection or strong drift. For a detailed explanation of all the indexes, we recommend resorting to the literature provided below (sherwin et al 2017). Error bars are +/- 1 standard deviation.

The third term refers to whether the diversity is calculated within populations (alpha) or between populations (beta).

allelic richness (q = 0), Shannon information (q = 1), and heterozygosity (q = 2).



```{r, warning=FALSE}
basic.stats <- dartR.base::utils.basic.stats(data.gl)
basic.stats$overall
colMeans(basic.stats$Ho, na.rm = TRUE) #observed heterozygosity

divers <- dartR.base::gl.report.diversity(data.gl, table = FALSE, pbar = FALSE, verbose = 0)
divers$one_H_alpha
divers$one_H_beta
```

::: {.callout-note}
## Exercise

![](images/task.png){.class width="48" height="48"}

  * Can you compare observed versus expected heterozygosity per population? Why would they be different?

  * Which population has the lowest genetic diversity? What would this mean for the population?

  * Is inbreeding prominent in any population? What could cause this?
:::

# Population connectivity

`divMigrate` uses the method described in Sundqvist *et al.,* 2013 to plot the relative migration levels between population samples.

Nm (i.e., the effective number of migrants). This statistic incorporates complementary information from both Gst and D, suggesting it may be a more generally suitable measure of migration. When using Nm for calculating the percent of correct directions in the different simulation scenarios.

Alternatively, the number of private alleles provides an indication of genetic isolation. We use private alleles or alleles only present in one population as a sign of no migration.

```{r}
source("gl2gpop_FDD.R")
gl2gpop(data.gl, filename = "data/genepop.gen")
# dartR.base::gl2genepop(data.gl, outfile = "genepop.gen", outpath = getwd(), verbose = 5) # Not recognised by diveRsity
migration <- diveRsity::divMigrate(infile = "data/genepop.gen", boots = 100, stat = "Nm", plot_network = TRUE, para = TRUE, filter_threshold = 0.2)

colnames(migration$nmRelMig) <- adegenet::popNames(data.gl)
rownames(migration$nmRelMig) <- adegenet::popNames(data.gl)
migration$nmRelMig

# Private alleles
dartR.base::gl.report.pa(data.gl, plot.display = TRUE, verbose = 0)
```

::: {.callout-note}
## Exercise

![](images/task.png){.class width="48" height="48"}

  * Which populations are highly connected? 
  
  * How does this concur with knowledge on the dispersal ability and historical seascape of the species?

  * Does your connectivity changes if you use a different statistics (e.g. 'D' or 'gst')?
:::

# Natural selection in the context of adaptive divergence

Understanding natural selection is fundamental to properly understanding evolution. The basics of natural selection are relatively straightforward but surprisingly easily misunderstood. Our aim with this practical session is to use the R environment to actually demonstrate different methods to detect signals of selection.

::: {.callout-important}
## IMPORTANT 

Both analyses to identify natural selection are much stronger if you have reference genome for your species, so you can pinpoint the genes and their functions that are being selected.
:::

## $FST$-based outliers

**Good to detect strong selective pressure**

This method looks for $FST$ outliers from a list of $FST$'s for different loci. It assumes that each locus has been genotyped in all populations with approximately equal coverage. Here, we identify loci 'putatively' under selection per population using the ***outflank*** method of Whitlock and Lotterhos (2015).

OutFLANK estimates the distribution of $FST$ based on a trimmed sample of $FST$'s. It assumes that the majority of loci in the center of the distribution are neutral and infers the shape of the distribution of neutral $FST$ using a trimmed set of loci. Loci with the highest and lowest $FST$'s are trimmed from the data set before this inference, and the distribution of $FST df/(mean FST)$ is assumed to follow a chi-square distribution. Based on this inferred distribution, each locus is given a q-value based on its quantile in the inferred null distribution.

More information here:

[Detection of the signal of selection from genome scan](https://popgen.nescent.org/2016-01-26-SNP-selection.html)


```{r}
outliers <- dartR.popgen::gl.outflank(data.gl,
                        plot = TRUE,
                        LeftTrimFraction = 0.05,
                        RightTrimFraction = 0.05,
                        Hmin = 0.1,
                        qthreshold = 0.05,)
outliers$outflank$numberLowFstOutliers
outliers$outflank$numberHighFstOutliers
```

## Genotype-Environment associations

**Better at detecting weak selective pressures**

Here, we illustrate the use of ***Redundancy Analysis (RDA)*** as a genotype-environment association (GEA) method to detect loci under selection (Forester et al., 2018). RDA is a multivariate ordination technique that can be used to analyze many loci and environmental predictors simultaneously. RDA determines how groups of loci co-vary in response to the multivariate environment, and can detect processes that result in weak, multilocus molecular signatures (Forester et al., 2018).

More information here:
[Detecting multilocus adaptation using Redundancy Analysis (RDA)](https://popgen.nescent.org/2018-03-27_RDA_GEA.html)

```{r}
data.gl.imputed <- dartR.base::gl.impute(data.gl, parallel = FALSE) # no missing data allowed
gen <- as.data.frame(data.gl.imputed)
predictor <- as.data.frame(data.gl.imputed@other$ind.metrics)
psych::pairs.panels(predictor[,2:4], scale = T, cex.cor = 3) #to check correlation between pairs

# For simplicity, we take the population as a proxy for environment (and sex a s a covariate), but ideally you have fine-scale environmental data for each individual. 
SNP_rda <- vegan::rda(gen ~ pop + Condition(sex), 
                      data = predictor, scale = TRUE) 
summary(SNP_rda)$cont$importance[,1:4]
summary(vegan::eigenvals(SNP_rda, model = "constrained"))

# We have as many constrained ("RDA") axes as we have predictors 
# Residual variance is then modelled by PCA (the unconstrained "PC" axes)
# Variance explained by the environmental predictors is under "Proportion"
# and "Constrained" = equivalent to R2 in multiple regression,
# so it is biased & should be adjusted based on the # of predictors:

vegan::RsquareAdj(SNP_rda)
# Our constrained ordination explains about 6% of the variation
# Not surprising given our large # of SNPs and other processes at work 

SNP.aov <- anova(SNP_rda, test = "Chi", permutations = 100, parallel = 4) #run Anova on the result to see the significance level
print(SNP.aov)

# Finally let's check Variance Inflation Factors for our predictors (they should be ok)
vegan::vif.cca(SNP_rda)
# All are below 10 and most are below 5 = multicollinearity shouldn't be a problem

screeplot(SNP_rda, npcs = 20, ptype = "lines", bstick = F)

pop <- predictor$pop
col <- c("#ff7f00","#1f78b4","#ffff33","#a6cee3","#33a02c","#e31a1c")
plot(SNP_rda, choices = c(1, 2), type = "n", scaling = 3)
points(SNP_rda, display = "species", pch = 20, cex = 0.7, col = "gray32", scaling = 3)           # the SNPs
points(SNP_rda, display = "sites", pch = 21, cex = 1.3, col = "gray32", scaling = 3, bg = col[pop]) # the individuals
text(SNP_rda, scaling = 3, display = "bp", col = "#0868ac", cex = 1)                           # the predictors
legend("bottomright", legend = levels(pop), bty = "n", col = "gray32", pch = 21, cex = 1, pt.bg = col)



# Identify candidates
# -------------------
load.rda <- vegan::scores(SNP_rda, choices = c(1:2), display = "species")  # Species scores for the first three constrained axes
hist(load.rda[,1], main = "Loadings on RDA1")
hist(load.rda[,2], main = "Loadings on RDA2")

# This simple function identifies the SNPs that load in the tails of these distributions. 
# Outliers are defines as 3 standard deviation cut-off (two-tailed p-value = 0.0027).
outliers <- function(x,z){
  lims <- mean(x) + c(-1, 1) * z * sd(x)     # find loadings +/-z sd from mean loading
  x[x < lims[1] | x > lims[2]]               # locus names in these tails
}

cand1 <- outliers(load.rda[,1],3)
cand2 <- outliers(load.rda[,2],3)
print(length(cand1) + length(cand2))
```



# Relatedness

Testing relatedness and kinship in your data can be very tricky. Relatedness estimates can be strongly biased by: bad genotyping, DNA contamination, populations structure, inbreeding, etc.

## Convert data

```{r}
relate <- dartR.base::gl2related(data.gl, verbose = 0)
pop.code <- substr(data.gl$pop, start = 1, stop = 2) #Related only takes 2 letter code for population
relate$V1 <- paste0(pop.code, "_", relate$V1)
```

## Run coancestry on full data

```{r, eval=FALSE}
pw.rel <- related::coancestry(relate, lynchli = 1, lynchrd = 1,trioml = 0L, dyadml = 0L,
                               quellergt = 1, wang = 1, ritland = 1)

save(pw.rel, file = "data/relatedness.Rdata")
```

```{r, eval=TRUE}
print(load("data/relatedness.Rdata"))

res <- pw.rel$relatedness

plot.data <- tidyr::gather(res, condition, measurement, 5:11, factor_key = TRUE)
summ <- dplyr::group_by(res, group) %>%
    dplyr::summarise(mean(ritland))

kableExtra::kbl(summ) %>%
  kableExtra::kable_styling(full_width = FALSE, font_size = 11)

plot <- ggplot2::ggplot(plot.data[plot.data$condition == "wang",], 
                        ggplot2::aes(x = group, y = measurement, 
                                                fill = group)) + 
  ggplot2::geom_boxplot() +
  ggplot2::facet_wrap(condition~.) +
  ggplot2::labs(x = "Site", y = "Relatedness") +
  ggplot2::theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
print(plot)

hist.plot <- ggplot2::ggplot(plot.data[plot.data$measurement > 0.1 & 
                        plot.data$group == "VaVa" & 
                        plot.data$condition == "wang",],
                        ggplot2::aes(x = measurement)) +
  ggplot2::geom_histogram(colour = "black", fill = "lightgray", bins =  100) +
  ggplot2::labs(x = "Wang - relatedness",
                y = "Frequency")
print(hist.plot)
```

## One population

In reality, relatedness should only be estimated with a single population.

```{r}
popname <- "Van Diemen Gulf"

relate.1pop <- dartR.base::gl2related(data.gl[data.gl$pop == popname,], verbose = 0)
pop.code <- "Va" #Related only takes 2 letter code for population
relate.1pop$V1 <- paste0(pop.code, "_", relate.1pop$V1)
```

```{r, eval=FALSE}
pw.rel.1pop <- related::coancestry(relate.1pop, lynchli = 1, lynchrd = 1,trioml = 0L, dyadml = 0L,
                               quellergt = 1, wang = 1, ritland = 1)

save(pw.rel.1pop, file = "data/relatedness_1pop.Rdata")
```

```{r}
print(load("data/relatedness_1pop.Rdata"))

res.1pop <- pw.rel.1pop$relatedness
plot.data.1pop <- tidyr::gather(res.1pop, condition, measurement, 5:11, factor_key = TRUE)

hist.plot <- ggplot2::ggplot(plot.data.1pop[plot.data.1pop$measurement > 0 & 
                        plot.data.1pop$condition == "wang",],
                        ggplot2::aes(x = measurement)) +
  ggplot2::geom_histogram(colour = "black", fill = "lightgray", bins =  100) +
  ggplot2::labs(x = "Wang - relatedness",
                y = "Frequency")
print(hist.plot)

high.rel <- plot.data.1pop[plot.data.1pop$measurement > 0.2 & 
                        plot.data.1pop$condition == "wang",]

hist.plot <- ggplot2::ggplot(high.rel, ggplot2::aes(x = measurement)) +
  ggplot2::geom_histogram(colour = "black", fill = "lightgray", bins =  10) +
  ggplot2::labs(x = "Wang - relatedness",
                y = "Frequency")
print(hist.plot)

kableExtra::kbl(high.rel[1:20, c(2:6)], 
  longtable = TRUE, booktabs = TRUE) %>%
  kableExtra::kable_styling(full_width = FALSE,font_size = 9, 
                            latex_options = c("repeat_header", "hold_position"))
```

# Sex-linked markers

See Robledo-Ruiz et al. (2023) and Devloo-Delva et al. (2023b).

## Load data

### Bull Shark

```{r}
print(load("data/Bull_shark_DArTseq_genlight_for_Sex-linked_markers.Rdata"))
```

### Blue Shark

```{r}
print(load("data/Blue_shark_DArTseq_genlight_for_sex-linked_markers.Rdata"))
```

### Run `filter.sex.linked`

![Markers on X and Y chromosomes](images/XY.png)

```{r, results="hold"}
res <- dartR.sexlinked::filter.sex.linked(gl = data.gl, system = "xy", plots = TRUE, ncores = 1)
```

### Run `infer.sex`

```{r}
sexID <- dartR.sexlinked::infer.sex(gl_sex_filtered = res, system = "xy", seed = 124)
knitr::kable(head(sexID))
```


# Extra resources

**These tutorials provide great examples of additional analyses.**

["Population Genetics in R" by Kamvar et al. 2016](https://popgen.nescent.org/index.html)

[Adegenet Tutorials by Thibaut Jombart](https://github.com/thibautjombart/adegenet/wiki/Tutorials)

[evolutionary genetics tutorial](https://evolutionarygenetics.github.io/)

["Computational Genomics with R" by Altuna Akalin](https://compgenomr.github.io/book/)


# References


Devloo-Delva, F., Burridge, C. P., Kyne, P. M., Brunnschweiler, J. M., Chapman, D. D., Charvet, P., ... & Feutry, P. (2023a). From rivers to ocean basins: The role of ocean barriers and philopatry in the genetic structuring of a cosmopolitan coastal predator. Ecology and Evolution, 13(2), e9837. <https://doi.org/10.1002/ece3.9837>

Devloo-Delva, F., Gosselin, T., Butcher, P. A., Grewe, P. M., Huveneers, C., Thomson, R. B., ... & Feutry, P. (2023b). An R-based tool for identifying sex-linked markers from restriction site-associated DNA sequencing with applications to elasmobranch conservation. Conservation genetics resources, 1-6. <https://doi.org/10.1007/s12686-023-01331-5>

Feutry, P., Devloo‐Delva, F., Tran Lu Y, A., Mona, S., Gunasekera, R. M., Johnson, G., ... & Kyne, P. M. (2020). One panel to rule them all: DArTcap genotyping for population structure, historical demography, and kinship analyses, and its application to a threatened shark. Molecular Ecology Resources, 20(6), 1470-1485. <https://doi.org/10.1111/1755-0998.13204>

Forester BR, Lasky JR, Wagner HH, Urban DL (2018) Comparing methods for detecting multilocus adaptation with multivariate genotype-environment associations. Molecular Ecology 27, 2215-2233. <https://doi.org/10.1111/mec.14584>

Kamvar, Z. N., López-Uribe, M. M., Coughlan, S., Grünwald, N. J., Lapp, H., & Manel, S. (2016). Developing educational resources for population genetics in R: An open and collaborative approach. Molecular Ecology Resources. <https://doi.org/10.1111/1755-0998.12558>

Nikolic, N., Devloo-Delva, F., Bailleul, D., Noskova, E., Rougeux, C., Delord, C., ... & Arnaud‐Haond, S. (2023). Stepping up to genome scan allows stock differentiation in the worldwide distributed blue shark *Prionace glauca*. Molecular Ecology, 32(5), 1000-1019. <https://doi.org/10.1111/mec.16822>

Pew, J., Muir, P. H., Wang, J., & Frasier, T. R. (2015). related: an R package for analysing pairwise relatedness from codominant molecular markers. Molecular ecology resources, 15(3), 557-561. <https://doi.org/10.1111/1755-0998.12323>

Robledo-Ruiz, D. A., Austin, L., Amos, J. N., Castrejón-Figueroa, J., Harley, D. K. P., Magrath, M. J. L., Sunnucks, P., & Pavlova, A. (2023). Easy-to-use R functions to separate reduced-representation genomic datasets into sex-linked and autosomal loci, and conduct sex assignment. Molecular Ecology Resources, 00, 1--21. <https://doi.org/10.1111/1755-0998.13844>

Sherwin, W.B., Chao, A., Johst, L., & Smouse, P.E. (2017). Information Theory Broadens the Spectrum of Molecular Ecology and Evolution. TREE 32(12) 948-963. <https://doi.org/10.1016/j.tree.2017.09.012>

Waples, R. S. (2015). Testing for Hardy–Weinberg proportions: have we lost the plot?. Journal of heredity, 106(1), 1-19. <https://doi.org/10.1093/jhered/esu062>

Whitlock MC & Lotterhos KE. 2015. Reliable Detection of Loci Responsible for Local Adaptation: Inference of a Null Model through Trimming the Distribution of FST. American Naturalist. 186, no. S1: S24-S36. <https://doi.org/10.1086/682949>

# Session information

```{r}
options(width = 100)
devtools::session_info()
```

