# Let's get started {.unnumbered}

```{r setup, include=FALSE}
library(knitr)
library(formatR)
library(tidyverse)

knitr::opts_chunk$set(tidy = TRUE, tidy.opts = list(width.cutoff = 72),
                      cache = TRUE,
                      echo = TRUE)
```

# Load packages

```{r, warning=FALSE, message=FALSE}
library(dartRverse)
library(adegenet)
library(diveRsity)
library(snpStats) #only for LD
library(ggtern) # for HWE diagnostics
library(related)
```

# Data introduction

We have made three dataset available for this tutorial. **Pick one:**

1.  Bull shark DArTcap data

2.  Northern River shark DArTcap data

3.  Blue Shark DArTseq data

## Bull shark

Data from @devloo_bull.

![The Bull Shark](images/Bull_Shark.jpg)

```{r, eval=FALSE}
data.file <- "data/Bull_shark_DArTcap_1rowGT.csv"
metadata.file <- "data/Bull_shark_DArTcap_metadata.csv"
```

## Northern River shark

Data from @feutry_glyphis.

Around 470 *G. garricki* samples were collected from 11 different sampling locations in Northern Australia and Papua New Guinea.

![The Northern River shark](images/Northern_River_Shark.jpg)

```{r}
data.file <- "data/Northern_river_shark_DArTcap_1rowGT.csv"
metadata.file <- "data/Northern_river_shark_DArTcap_metadata.csv"
```

## Blue shark

Data from @nikolic_blue.

![The Blue Shark](images/Blue_shark.jpg)

```{r, eval=FALSE}
data.file <- "data/Blue_shark_DArTSeq_1rowGT_subset.csv"
metadata.file <- "data/Blue_shark_DArTseq_metadata.csv"
```

# Reading and filtering raw data

For the purpose of this workshop we will use the `dartRverse` packages to read and filter the data [@gruber_dartr; @mijangos_dartr2].

## Import data

```{r}
data.gl <- dartR.base::gl.read.dart(filename = data.file,
                                ind.metafile = metadata.file, 
                                verbose = 1)
```

## Save raw data

```{r, eval=FALSE}
save(data.gl, file = "data/raw_genlight.Rdata")
```

## Quality filtering

The order of filtering can be important and requires some thought. The filtering steps may change depending on the analysis you intend to run. There is no one-fits-all approach to SNP filtering.

::: callout-warning
Be careful not to over-filter. The objective is to get an appropriate balance between signal to noise ratio, not to eliminate noise altogether at the expense of also taking out some signal. This balance will depend on downstream application.

*A good strategy is to undertake an exploratory analysis first, whereby you experiment with filtering. Perhaps start with very stringent filtering, examine the impact on the final analysis, then progressively reduce the stringency to select the minimal filtering regime that still delivers a stable outcome. Play with your data to get a feel for the balance between signal to noise ratio, in the context of the analyses you propose to subsequently undertake.*
:::

### Average reproducibility

DArT includes several technical replicates (\~30 %) of your samples to see how reproducible the results are. Some SNPs are less reliable than others.

*This metric is based on all individuals in your original dataset.*

**It is not advised to filter on reproducibility \> 0.99, since you are like to remove more heterozygous SNPs (i.e. more difficult to genotype consistently).**

:::{.panel-tabset}
##### Report reproducibility
```{r}
dartR.base::gl.report.reproducibility(data.gl, verbose = 1)
```
##### Filter reproducibility
```{r}
data.gl <- dartR.base::gl.filter.reproducibility(data.gl, threshold = 0.98, 
                                                 plot.colors = c("#2171B5", "#6BAED6"),
                                                 verbose = 1)
```
:::

### Invariable sites

You want to remove SNP that are not informative for population-level analyses. This will improve computation time and reduce the noise in the data.

#### All NA

Removes SNPs that have missing data for all samples.

```{r}
data.gl <- dartR.base::gl.filter.allna(data.gl, verbose = 1)
```

#### Monomorphic

Looks for loci which are all 0 (or 1 or 2) over the all samples. These are not informative.

:::{.panel-tabset}
##### Report monomorphs
```{r}
dartR.base::gl.report.monomorphs(data.gl, verbose = 1)
```
##### Filter monomorphs
```{r}
data.gl <- dartR.base::gl.filter.monomorphs(data.gl, verbose = 5)
```
:::

#### Minor Allele Frequency

Some mutations only occur in a couple of individuals, these are not informative for population-level analyses. Loci with a low Minor Allele Frequency (MAF) might not be informative enough and just increase computation time.

::: callout-warning
The threshold should be lower than the proportion of your smallest sampling location. For example, if one of your sample sites has 5 samples out of a total of 100 samples, the MAF should not be \< 0.05. Else, your risk loosing the informative markers that differntiate that population.
:::

:::{.panel-tabset}
##### Report maf
```{r}
dartR.base::gl.report.maf(data.gl, verbose = 1)
```
##### Filter maf
```{r}
data.gl <- dartR.base::gl.filter.maf(data.gl, threshold = 0.005, 
                                     plot.colors = c("#2171B5", "#6BAED6"),
                                     verbose = 1)
```
:::


### Read depth

Read depth has a considerable influence on the veracity of SNP calls. The low values arise because of chance variation in the coverage of particular bases. The high values arise because of the differential efficiency of the PCR steps or paralogous fragments. Under some circumstances, it might be sensible to push the lower threshold for read depth higher than has been used by the Diversity Arrays Technology in their report. Analyses that rely heavily on the accuracy of calls of heterozygotes may require a higher threshold for read depth, say 10x, for example.

**Check the histogram to see how many SNP have low or high counts. Low counts might not be reliably genotyped. High counts may be due to paralogous fragments.**

:::{.panel-tabset}
##### Report rdepth
```{r}
dartR.base::gl.report.rdepth(data.gl, verbose = 1)
```
##### Filter rdepth
```{r}
data.gl <- dartR.base::gl.filter.rdepth(data.gl, lower = 5, upper = 200, verbose = 1)
```
:::


### Missing data for SNPs

Call rate is defined as `1 - proportion of missing data`. SNPs with too much missing data are not reliable and informative.

Call Rate for SNPs can arise from two sources. The first source is where a missing value arises because the sequence tag bearing the target SNP cannot be amplified -- there has been a mutation at one or both of the restriction sites. The second source of missing values is where the read depth is insufficient to make a reliable call on the SNP. Either way, the SNP is not called and is recorded as NA. A first step in filtering on Call Rate is to examine the distribution of Call Rates across loci. We use the function `gl.report.callrate` to yield the following output and graph.

:::{.panel-tabset}
##### Report SNP callrate
```{r}
dartR.base::gl.report.callrate(data.gl, method = "loc", verbose = 1)
```
##### Filter SNP callrate
```{r}
data.gl <- dartR.base::gl.filter.callrate(data.gl, method = "loc",  threshold = 0.8, verbose = 1)
```
:::


### Missing data for individuals

Call rate is defined as `1 - proportion of missing data`. Samples with degraded DNA will have a lot of missing sequencing data. These samples are unreliably sequenced and should be removed.

:::{.panel-tabset}
##### Report ind. callrate
```{r}
dartR.base::gl.report.callrate(data.gl, method = "ind", verbose = 1)
```
##### Filter ind. callrate
```{r}
data.gl <- dartR.base::gl.filter.callrate(data.gl, method = "ind", threshold = 0.8, verbose = 1)
```
:::


### Individual heterozygosity

Delete individuals with a heterozygosity below or above the threshold. High heterozygosity could be due to DNA cross-contamination from other individuals. Low heterozygosity could be due to population structure, inbreeding or excess missing values (normally the latter should be filtered out already).

:::{.panel-tabset}
##### Report ind. heterozygosity
```{r}
dartR.base::gl.report.heterozygosity(data.gl, method = "ind", verbose = 1)
```
##### Filter ind. heterozygosity
```{r}
data.gl <- dartR.base::gl.filter.heterozygosity(data.gl, t.lower = 0, t.upper = 0.3,  verbose = 1)
```
:::


### Invariable sites

When filtering has resulted in removal of some individuals or populations, variation at several loci may be lost. Some loci may even be scored as missing across all individuals. You may wish to remove these monomorphic loci from your dataset.

:::{.panel-tabset}
##### Filter missing data
```{r}
data.gl <- dartR.base::gl.filter.allna(data.gl, verbose = 1)
```
##### Report monomorphs
```{r}
dartR.base::gl.report.monomorphs(data.gl, verbose = 1)
```
##### Filter monomorphs
```{r}
data.gl <- dartR.base::gl.filter.monomorphs(data.gl, verbose = 1)
```
:::


### Linked loci

SNPs that are close together will be inherited together. Consequently, linked SNPs are not independent and will bias the data by inflating the signal.

::: callout-tip
Do not filter on LD, if you aim to analyse you data of effective population size based on linkage disequilibrium.
:::

#### Short-distance linkage

Sequence tags can contain more than one callable SNP marker. Because of their close proximity, these multiple SNPs within a single sequence tag (referred to in dartR as **'secondaries'** are likely to be strongly linked (inherited together). This is problematic for many analyses, so one might wish to filter out the multiple SNPs to leave only one per sequence tag.

This function removes SNPs on the same 70 bp sequence tag, it retains the SNP with the highest RepAvg (average reproducibility) andrAvgPIC (average polymorphic information content), respectively.

:::{.panel-tabset}
##### Report secondaries
```{r}
dartR.base::gl.report.secondaries(data.gl, verbose = 1)
```

##### Filter secondaries
```{r}
data.gl <- dartR.base::gl.filter.secondaries(data.gl, method = "best", verbose = 1)

```
:::

#### Long-distance linkage

**Not running this because it takes too long, but consider using this if you have many SNPs and a small genome.**

:::{.panel-tabset}
##### Report ld.map
```{r, eval=FALSE}
ld.report <- dartR.base::gl.report.ld.map(data.gl, ld.stat = "R.squared", verbose = 1)
# changes between ''.' and '_' depending on your version of snpStats
ld.report$ld_stat <- ld.report$ld.stat 
ld.report$locus_a.stat_keep <- ld.report$locus_a.stat.keep
ld.report$locus_b.stat_keep <- ld.report$locus_b.stat.keep
```
##### Report ld
```{r, eval=FALSE}
dartR.base::gl.report.ld(data.gl, verbose = 1)
```
##### Filter
```{r, eval=FALSE}
data.gl <- dartR.base::gl.filter.ld(data.gl, ld.report, threshold = 0.25, verbose = 1)
```
:::


### Hardy-Weinberg Equilibrium

The Hardy--Weinberg equilibrium (HWE) states that allele and genotype frequencies in a population will remain constant from generation to generation in the absence of other evolutionary influences. SNPs that are sampled from a population in demographic equilibrium are expected to follow this equation: $p^2 + 2pq + q^2 = 1$, where $p$ is the frequency of the major allele (A) and $q$ is frequency of the minor allele (a).

In the simplest case of a single locus with two alleles denoted A and a with frequencies $f(A) = p$ and $f(a) = q$, respectively, the expected genotype frequencies under random mating are $f(AA) = p^2$ for the AA homozygotes, $f(aa) = q^2$ for the aa homozygotes, and $f(Aa) = 2pq$ for the heterozygotes.

::: callout-warning
There are several factors that can cause deviations from Hardy-Weinberg proportions including:

-   Mutations
-   Finite population size
-   Selection
-   Population structure
-   Age structure
-   Assortative mating
-   Sex linkage
-   Non-random sampling
-   Genotyping errors

Therefore, testing for Hardy-Weinberg proportions should be a process that involves a careful evaluation of the results, a good place to start is Waples (2015). Note that tests for H-W proportions are only valid if there is no population substructure (assuming random mating) and have sufficient power only when there is sufficient sample size (n individuals \> 15).
:::

:::{.panel-tabset}
##### hwe diagnostics
```{r}
dartR.base::gl.diagnostics.hwe(data.gl, verbose = 1)
```
##### Report hwe
```{r}
dartR.base::gl.report.hwe(data.gl, verbose = 1)
```
##### Filter hwe
```{r}
data.gl <- dartR.base::gl.filter.hwe(data.gl, n.pop.threshold = 3, 
                                     mult.comp.adj = TRUE, 
                                     mult.comp.adj.method = "BH", 
                                     verbose = 1)
```
:::


### Remove duplicate individuals

Since DArT includes technical replicates and you could potentially recapture individuals, it important to remove replicate individuals. Duplicates individuals will inflate the signal you are investigating.

```{r}
res_dup <- dartR.base::gl.report.replicates(data.gl,loc_threshold = 500, perc_geno = 0.85)
```

## Filtering Conclusion

**Influence of Planned Analyses**

Possibly the most influential consideration on filtering is the purpose for which the filtered data set is to be used.

-   If you are planning to generate ***high resolution linkage maps***, then highly stringent filtering is warranted, and Diversity Arrays Technology would adjust their pipelines accordingly upon request. Similarly, if you are contemplating an analysis of ***relatedness or inbreeding***, then stringent filtering might be warranted. In any case, it would be wise to start out with high stringency and then progressively relax the stringency and examine the impact on outcomes.

-   If your focus is on identifying ***sex-linked markers***, which rely heavily on identifying markers that are heterozygous in XY individuals and homozygous in XX individuals, then a filtering threshold for read depth of 10x would be sensible. Sequencing volume in the context of genome size will provide an upper limit to how far you can push the read depth threshold, so in some cases, a high sequence volume service will need to be requested. Because the pipelines of Diversity Arrays Technology depend in part on Mendelian behaviour in the selection of SNP markers, and sex-linked loci do not behave in Mendelian fashion, you might also ask them to relax the stringency of some aspects of their filtering in generating the report.

-   If your focus is on ***Genome-wide Association Studies (GWAS)*** or identifying ***loci under selection***, then noise in the data will not associate with phenotype, and so filtering can be less stringent in order to maximize the chances of identifying promising associations.

-   ***Principal Coordinates Analysis*** PCA (and to a lesser extent, ***Principal Components Analysis***, PCoA), rely on fully populated data matrices (no missing values). Classical PCA for example, cannot easily accommodate missing values. To overcome this, a balance must be struck between filtering on Call Rate and imputing the values of those missing values that remain. More stringent filtering on Call Rate, and less imputation; but more stringent filtering on Call Rate, more loss of potentially useful information or valuable samples. Refer to @Georges2023 for further discussion of this point.

::: callout-tip
There is no hard and fast rule to guide decisions on filtering SNP datasets prior to a substantive analysis. The decisions are based on comparing the distribution of the parameters to be filtered (using one of the gl.report functions) and the purpose to which the filtered dataset is to be put. Sequencing volume can constrain options, and the likelihood of some level of contamination of samples or presence of inhibitors of the restriction enzymes can have a bearing on the decisions. It is important not to over filter because of the risk of introducing a level of systematic bias and because of the unnecessary loss of informative loci or individuals. An experimental approach is recommended, whereby different filtering regimes are tried (from stringent to less stringent) and checked for influence on analysis outcomes.
:::

# Population structure

Inferring ancestry differences among individuals from different populations, or identifying population structure has been motivated by many applications:

-   Population genetics

-   Genetic association studies

-   Prediction of whether an individual will have particular traits (for instance in people that have the duffy antigen that allows them to have resistance to malaria)

Until recently we were only able to group individuals into populations using a few genetic markers. However, the decrease in cost and improvements in technology mean that is now feasible to use whole genomes to perform these kinds of analyses. This means that we can now have very fine scaled analyses of populations based on many thousands of markers.

Examining population structure can give us a great deal of insight into the history and origin of populations. Model-free methods for examining population structure and ancestry, such as ***principal components analysis*** are extremely popular in population genomic research. This is because it is typically simple to apply and relatively easy to interpret.

## Principal Component Analysis

Principal components analysis (PCA) is the most commonly recognised and used method for identifying population structure. Essentially, PCA aims to identify the main axes of variation in a dataset with each axis being independent of the next (i.e. there should be no correlation between them). The first component summarizes the major axis variation and the second the next largest and so on, until cumulatively all the available variation is explained. In the context of genetic data, PCA summarizes the major axes of variation in allele frequencies and then produces the coordinates of individuals along these axes. For the rest of the tutorial we will conduct a PCA to demonstrate how it can help give insight to population structure within species.

This analysis allows us to calculate principal components (PCs) that explain the differences between individuals in genetic data. The naming of each of these components is based on the percentage of variation in the data they explain, with principal component 1 (PC1) being the most explanatory PC of the data. For instance if PC1 explains 5.7%. PC2 will have the next largest contribution to the genetic variance, for example PC2 may contribute 3.4%. The overall variance should add up to 100%.

```{r}
PCA <- dartR.base::gl.pcoa(data.gl, nfactors = 5, verbose = 0)
dartR.base::gl.pcoa.plot(PCA, data.gl, xaxis = 1, yaxis = 2, verbose = 0)
dartR.base::gl.pcoa.plot(PCA, data.gl, xaxis = 2, yaxis = 3, verbose = 0)
```

::: callout-note
## Exercise

![](images/task.png){#id .class width="48" height="48"}

-   How many genetic clusters are present across the sequenced samples? A cluster can be defined as a group of individuals that are genetically very similar to each other. Each cluster is genetically distinct from other clusters.

-   What is the relationship among these genetic clusters? i.e. which cluster is the most genetically distinct? Which genetic clusters are most similar to one another?

-   How many PCs is it worth plotting?

-   Can you identify the cluster membership of each individual? There are a variety of ways to do this. For example, you can look at the `PCA$scores` and sort the columns by PC.
:::

## Fixation indices

$FST$, also known as the fixation index, is an extremely important statistic in population genetics, molecular ecology and evolutionary biology. It is also arguably one of the most famous population genetic statistics you will encounter. $FST$ essentially measures the level of genetic differentiation between two or more populations. It ranges from 0 (i.e. no genetic differentiation) to 1 (complete genetic differentiation)

Ultimately, it is quite a simple statistic to understand but it can sometimes take time to properly grasp. So we will go over the basics properly here. One of the most confusing things about $FST$ is that are several different ways to define it. For ease of understanding, we will use a simple formulation:

$FST=(HT−HS)/HT$

For simplicity, imagine we are examining two populations only. With this formulate, $HT$ is the expected heterozygosity when the two populations are considered as one large meta-population. $HS$ is the average expected heterozygosity in the two populations.

You might be thinking, hang on a minute... what do we mean by expected heterozygosity? To appreciate this, we need to think back to the Hardy-Weinberg expectation we learned about in Section 4.3.9. Remember that at a simple bi-allelic locus, $p$ and $q$ are the frequencies of the two alleles. We can calculate the expected frequency of heterozygotes with $2pq$ - this is the expected heterozygosity.

You can use $FST$ to identify the relationship between individuals, and it can be used to identify populations. To do this, you first need to define the members of each of your populations. You did this at the end of the PCA section where you identified cluster membership.

```{r, warning=FALSE}
fst.res <- dartR.base::gl.fst.pop(data.gl, nboots = 100, verbose = 0)
fst.res$Fsts
fst.res$Pvalues
## correction for multiple testing: Bonferroni, Benjamini-Hochberg
Fst.p.adj <- stats::p.adjust(fst.res$Pvalues, "BH")
Fst.p.adj <- matrix(Fst.p.adj, ncol = adegenet::nPop(data.gl))
colnames(Fst.p.adj) <- adegenet::popNames(data.gl)
rownames(Fst.p.adj) <- adegenet::popNames(data.gl)
Fst.p.adj

fixed.diff <- dartR.base::gl.fixed.diff(data.gl, tloc = 0.1, verbose = 0)
fixed.diff$fd
```

::: callout-note
## Exercise

![](images/task.png){.class width="48" height="48"}

-   Do the $FST$ metrics support the PCA results?

-   Do you see a different significance in p-values when correcting for multiple comparisons?
:::

# Genetic diversity

Genetic variability of populations of a species is important because it can be thought of an indirect measure of the evolvability of those populations. The greater the genetic diversity of a population the bigger the amount of genetic raw material upon which selection can act. A population deprived of its genetic variability is less likely to respond to environmental changes and more vulnerable to the negative effects of inbreeding. From a theoretical point of you measuring (correctly) genetic diversity of a population and comparing it among different naturally occurring or human driven treatments might be important to test the theoretical predictions on impact of drift on effect of population size of relatively isolated (small) populations and on mechanisms of genetic variance (diversity) maintenance. From the conservation point of view the relative genetic diversity of population differentially affected by human intervention might give insight into how resilient populations of a species are to rapid changes of the habitat in which they live.

  * **Ho = Observed heterozygosity**

      $Ho= 1-\sum_k \sum_i  Pkii/np$
      
      where $Pkii$ represents the proportion of homozygote $i$ in sample $k$ and $np$ the number of samples.

  * **Hs = Within population gene diversity (sometimes misleadingly called expected heterozygosity, He)**

      $Hs=\tilde{n}/(\tilde{n}-1)[1-\sum_i\bar{p_i^2}-Ho/2\tilde{n}]$
      
      where $\tilde{n}=np/\sum_k 1/n_k$ and $\bar{p_i^2}=\sum_k p_{ki}^2/np$


  * **Ht = Overall gene diversity**

      $Ht= 1-\sum_i\bar{p_i}^2+Hs/(\tilde{n} np)-Ho/(2\tilde{n}np)$
      
      where $\bar{p_i}=\sum_kp_{ki}/np$.

  * **Dst = Amount of gene diversity among samples**

      $Dst=Ht-Hs$

  * **Htp = corrected Ht**

      $Ht'=Hs+Dst'$
  
  * **Dstp = Corrected Dst**
  
      $Dst'=np/(np-1)Dst$

  * **Fst = Fixation index**

      $Fst=Dst/Ht$ (This is not the same as Nei's $Gst$)

  * **Fstp = Corrected Fst**

      $Fst'=Dst'/Ht'$


  * **Fis = Inbreeding coefficient**

      $Fis=1-Ho/Hs$


  * **Dest =  a measure of population differentiation as defined by @jost2008gst**

      $Dest=np/(np-1) (Ht'-Hs)/(1-Hs)$
      
      where $p_{ki}$ are unweighted by sample size.

  * **Gst = an estimator of $Fst$ based on allele frequencies only**


```{r, warning=FALSE}
basic.stats <- dartR.base::utils.basic.stats(data.gl)
basic.stats$overall
colMeans(basic.stats$Ho, na.rm = TRUE) #observed heterozygosity

hets <- gl.report.heterozygosity(data.gl, method = "pop")
```

**Some alternate measures for genetic diversity are more comparable between datasets.This is provided by the `gl.report.diversity` function.**

The output of this function: provide information for different indices: allelic richness (q = 0), Shannon information (q = 1), and heterozygosity (q = 2); within (alpha) or between (beta) populations. For all indexes, the entropies (H) and Hill numbers (D) are calculated.

In a nutshell, the alpha indexes between the different q-values should be similar if there is no deviation from expected allele frequencies and occurrences (e.g. all loci in HWE & equilibrium). If there is a deviation of an index, this links to a process causing it, such as dispersal, selection or strong drift. For a detailed explanation of all the indexes see @sherwin.

```{r}
divers <- dartR.base::gl.report.diversity(data.gl, table = FALSE, pbar = FALSE, verbose = 0)
divers$one_H_alpha
divers$one_H_beta
```

::: callout-note
## Exercise

![](images/task.png){.class width="48" height="48"}

-   Can you compare observed versus expected heterozygosity per population? Why would they be different?

-   Which population has the lowest genetic diversity? What would this mean for the population?

-   Is inbreeding (FIS) prominent in any population? What could cause this?
:::

# Population connectivity

`divMigrate` uses the method described in @sundqvist_divmigrate to plot the relative migration levels between population samples.

Nm (i.e., the effective number of migrants). This statistic incorporates complementary information from both Gst and D, suggesting it may be a more generally suitable measure of migration. When using Nm for calculating the percent of correct directions in the different simulation scenarios.

Alternatively, the number of private alleles provides an indication of genetic isolation. We use private alleles (i.e. alleles only present in one population) as a sign of no migration.

```{r}
source("gl2gpop_FDD.R")
gl2gpop(data.gl, filename = "data/genepop.gen")
# dartR.base::gl2genepop(data.gl, outfile = "genepop.gen", outpath = getwd(), verbose = 5) # Not recognised by diveRsity
migration <- diveRsity::divMigrate(infile = "data/genepop.gen", boots = 100, stat = "Nm", plot_network = TRUE, para = TRUE, filter_threshold = 0.2)

colnames(migration$nmRelMig) <- adegenet::popNames(data.gl)
rownames(migration$nmRelMig) <- adegenet::popNames(data.gl)
migration$nmRelMig

# Private alleles
dartR.base::gl.report.pa(data.gl, plot.display = TRUE, verbose = 0)
```

::: callout-note
## Exercise

![](images/task.png){.class width="48" height="48"}

-   Which populations are highly connected?

-   How does this concur with knowledge on the dispersal ability and historical seascape of the species?

-   Does your connectivity changes if you use a different statistics (e.g. 'D' or 'gst')?
:::

# Natural selection in the context of adaptive divergence

Understanding natural selection is fundamental to properly understanding evolution. The basics of natural selection are relatively straightforward but surprisingly easily misunderstood. Our aim with this practical session is to use the R environment to actually demonstrate different methods to detect signals of selection.

::: callout-important
Both analyses to identify natural selection are much stronger if you have reference genome for your species, so you can pinpoint the genes and their functions that are being selected.
:::

## $FST$-based outliers

**Good to detect strong selective pressure**

This method looks for $FST$ outliers from a list of $FST$'s for different loci. It assumes that each locus has been genotyped in all populations with approximately equal coverage. Here, we identify loci 'putatively' under selection per population using the ***outflank*** method of @whitlock_outliers.

OutFLANK estimates the distribution of $FST$ based on a trimmed sample of $FST$'s. It assumes that the majority of loci in the center of the distribution are neutral and infers the shape of the distribution of neutral $FST$ using a trimmed set of loci. Loci with the highest and lowest $FST$'s are trimmed from the data set before this inference, and the distribution of $FST df/(mean FST)$ is assumed to follow a chi-square distribution. Based on this inferred distribution, each locus is given a q-value based on its quantile in the inferred null distribution.

More information here:

[Detection of the signal of selection from genome scan](https://popgen.nescent.org/2016-01-26-SNP-selection.html)

```{r}
outliers <- dartR.popgen::gl.outflank(data.gl,
                        plot = TRUE,
                        LeftTrimFraction = 0.05,
                        RightTrimFraction = 0.05,
                        Hmin = 0.1,
                        qthreshold = 0.05,)
outliers$outflank$numberLowFstOutliers
outliers$outflank$numberHighFstOutliers
```

## Genotype-Environment associations

**Better at detecting weak selective pressures**

Here, we illustrate the use of ***Redundancy Analysis (RDA)*** as a genotype-environment association (GEA) method to detect loci under selection (Forester et al., 2018). RDA is a multivariate ordination technique that can be used to analyze many loci and environmental predictors simultaneously. RDA determines how groups of loci co-vary in response to the multivariate environment, and can detect processes that result in weak, multilocus molecular signatures (Forester et al., 2018).

More information here: [Detecting multilocus adaptation using Redundancy Analysis (RDA)](https://popgen.nescent.org/2018-03-27_RDA_GEA.html)

```{r}
data.gl.imputed <- dartR.base::gl.impute(data.gl, parallel = FALSE) # no missing data allowed
gen <- as.data.frame(data.gl.imputed)
predictor <- as.data.frame(data.gl.imputed@other$ind.metrics)
psych::pairs.panels(predictor[,2:4], scale = T, cex.cor = 3) #to check correlation between pairs

# For simplicity, we take the population as a proxy for environment (and sex a s a covariate), but ideally you have fine-scale environmental data for each individual. 
SNP_rda <- vegan::rda(gen ~ pop + Condition(sex), 
                      data = predictor, scale = TRUE) 
summary(SNP_rda)$cont$importance[,1:4]
summary(vegan::eigenvals(SNP_rda, model = "constrained"))

# We have as many constrained ("RDA") axes as we have predictors 
# Residual variance is then modelled by PCA (the unconstrained "PC" axes)
# Variance explained by the environmental predictors is under "Proportion"
# and "Constrained" = equivalent to R2 in multiple regression,
# so it is biased & should be adjusted based on the # of predictors:

vegan::RsquareAdj(SNP_rda)
# Our constrained ordination explains about 6% of the variation
# Not surprising given our large # of SNPs and other processes at work 

SNP.aov <- anova(SNP_rda, test = "Chi", permutations = 100, parallel = 4) #run Anova on the result to see the significance level
print(SNP.aov)

# Finally let's check Variance Inflation Factors for our predictors (they should be ok)
vegan::vif.cca(SNP_rda)
# All are below 10 and most are below 5 = multicollinearity shouldn't be a problem

screeplot(SNP_rda, npcs = 20, ptype = "lines", bstick = F)

pop <- predictor$pop
col <- c("#ff7f00","#1f78b4","#ffff33","#a6cee3","#33a02c","#e31a1c")
plot(SNP_rda, choices = c(1, 2), type = "n", scaling = 3)
points(SNP_rda, display = "species", pch = 20, cex = 0.7, col = "gray32", scaling = 3)           # the SNPs
points(SNP_rda, display = "sites", pch = 21, cex = 1.3, col = "gray32", scaling = 3, bg = col[pop]) # the individuals
text(SNP_rda, scaling = 3, display = "bp", col = "#0868ac", cex = 1)                           # the predictors
legend("bottomright", legend = levels(pop), bty = "n", col = "gray32", pch = 21, cex = 1, pt.bg = col)



# Identify candidates
# -------------------
load.rda <- vegan::scores(SNP_rda, choices = c(1:2), display = "species")  # Species scores for the first three constrained axes
hist(load.rda[,1], main = "Loadings on RDA1")
hist(load.rda[,2], main = "Loadings on RDA2")

# This simple function identifies the SNPs that load in the tails of these distributions. 
# Outliers are defines as 3 standard deviation cut-off (two-tailed p-value = 0.0027).
outliers <- function(x,z){
  lims <- mean(x) + c(-1, 1) * z * sd(x)     # find loadings +/-z sd from mean loading
  x[x < lims[1] | x > lims[2]]               # locus names in these tails
}

cand1 <- outliers(load.rda[,1],3)
cand2 <- outliers(load.rda[,2],3)
print(length(cand1) + length(cand2))
```

# Relatedness

Two alleles are identical by descent (IBD) if they are identical copies of the same ancestral allele in a base population. Relatedness is the proportion of alleles shared between individuals that are IBD. Kinship is the probability that two alleles, one taken at random from each individual, are IBD [@wang2022_kinship]. Kinship considers half the genetic information because it looks at the probability that one individual inherits a particular allele from a common ancestor shared with another individual. Therefore, kinship is equal to half of relatedness.

::: callout-tip
Below is a table modified from @speed2015_relatedness showing kinship coefficients ($\theta$), and their confidence intervals (CI), and relatedness values for different relationships.

| Relationship                           | Kinship |    CI(95%)     |    r    |
|:---------------------------------------|:-------:|:--------------:|:-------:
| Identical twins/clones/same individual |   0.5   |       \-       |    1    |
| Sibling/Parent-Offspring               |  0.25   | (0.204, 0.296) |   0.5   |
| Half-sibling                           |  0.125  | (0.092, 0.158) |  0.25   |
| First cousin                           |  0.062  | (0.038, 0.089) |  0.125  |
| Half-cousin                            |  0.031  | (0.012, 0.055) |  0.062  |
| Second cousin                          |  0.016  | (0.004, 0.031) |  0.031  |
| Half-second cousin                     |  0.008  | (0.001, 0.020) |  0.016  |
| Third cousin                           |  0.004  | (0.000, 0.012) |  0.008  |
| Unrelated                              |    0    |       \-       |    0    |
:::

Note that the variance of relatedness depends on the number of SNPs and genome size, therefore even with perfect data your relatedness will not follow these expected values exactly.
![](images/r_distribution.png)

Further, in species with small population sizes (not uncommon in Chondrichthyes), inbreeding may skew the expected values even more.
![](images/r_FSFS.png)

::: callout-warning
Relatedness/kinship are not absolute states but are estimated relative to a reference population for which there is generally little information, so that we can estimate the kinship of a pair of individuals only relative to some other quantity.

All relatedness estimates assume the true allele frequencies of your natural populations are known. But **small samples size, missing data, DNA contamination, populations structure, inbreeding, and the presence of related individuals** in your data will bias your frequency distributions.

Previous studies showed that around 5,000 SNPs are sufficient to accurately estimate relatedness and kinship [@goudet_kiship].
:::




## Convert data

There are many good software available to estimate relatedness, such as COLONY2, sequoia, gcta64, EMIBD9, PC-Relate, etc. For this example, we use the `related` package [@pew_related].

```{r}
relate <- dartR.base::gl2related(data.gl, verbose = 0)
pop.code <- substr(data.gl$pop, start = 1, stop = 2) #Related only takes 2 letter code for population
relate$V1 <- paste0(pop.code, "_", relate$V1)
```

## Run coancestry on full data

```{r, eval=FALSE}
pw.rel <- related::coancestry(relate, lynchli = 1, lynchrd = 1,trioml = 0L, dyadml = 0L,
                               quellergt = 1, wang = 1, ritland = 1)

save(pw.rel, file = "data/relatedness.Rdata")
```


```{r, eval=TRUE}
print(load("data/relatedness.Rdata"))

res <- pw.rel$relatedness

plot.data <- tidyr::gather(res, condition, measurement, 5:11, factor_key = TRUE)
summ <- dplyr::group_by(res, group) %>%
    dplyr::summarise(mean(ritland))

kableExtra::kbl(summ) %>%
  kableExtra::kable_styling(full_width = FALSE, font_size = 11)

plot <- ggplot2::ggplot(plot.data[plot.data$condition == "wang",], 
                        ggplot2::aes(x = group, y = measurement, 
                                                fill = group)) + 
  ggplot2::geom_boxplot() +
  ggplot2::facet_wrap(condition~.) +
  ggplot2::labs(x = "Site", y = "Relatedness") +
  ggplot2::theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
print(plot)

hist.plot <- ggplot2::ggplot(plot.data[plot.data$measurement > 0.1 & 
                        plot.data$group == "VaVa" & 
                        plot.data$condition == "wang",],
                        ggplot2::aes(x = measurement)) +
  ggplot2::geom_histogram(colour = "black", fill = "lightgray", bins =  100) +
  ggplot2::labs(x = "Wang - relatedness",
                y = "Frequency")
print(hist.plot)
```

::: callout-note
## Exercise

Why do you have negative relatedness?

Why do some populations have very high relatedness?

:::

## One population

In reality, relatedness should only be estimated with a single population.

```{r}
popname <- "Van Diemen Gulf"

relate.1pop <- dartR.base::gl2related(data.gl[data.gl$pop == popname,], verbose = 0)
pop.code <- "Va" #Related only takes 2 letter code for population
relate.1pop$V1 <- paste0(pop.code, "_", relate.1pop$V1)
```

```{r, eval=FALSE}
pw.rel.1pop <- related::coancestry(relate.1pop, lynchli = 1, lynchrd = 1,trioml = 0L, dyadml = 0L,
                               quellergt = 1, wang = 1, ritland = 1)

save(pw.rel.1pop, file = "data/relatedness_1pop.Rdata")
```

```{r}
print(load("data/relatedness_1pop.Rdata"))

res.1pop <- pw.rel.1pop$relatedness
plot.data.1pop <- tidyr::gather(res.1pop, condition, measurement, 5:11, factor_key = TRUE)

hist.plot <- ggplot2::ggplot(plot.data.1pop[plot.data.1pop$measurement > 0 & 
                        plot.data.1pop$condition == "wang",],
                        ggplot2::aes(x = measurement)) +
  ggplot2::geom_histogram(colour = "black", fill = "lightgray", bins =  100) +
  ggplot2::labs(x = "Wang - relatedness",
                y = "Frequency")
print(hist.plot)

high.rel <- plot.data.1pop[plot.data.1pop$measurement > 0.2 & 
                        plot.data.1pop$condition == "wang",]

hist.plot <- ggplot2::ggplot(high.rel, ggplot2::aes(x = measurement)) +
  ggplot2::geom_histogram(colour = "black", fill = "lightgray", bins =  10) +
  ggplot2::labs(x = "Wang - relatedness",
                y = "Frequency")
print(hist.plot)

kableExtra::kbl(high.rel[1:20, c(2:6)], 
  longtable = TRUE, booktabs = TRUE) %>%
  kableExtra::kable_styling(full_width = FALSE,font_size = 9, 
                            latex_options = c("repeat_header", "hold_position"))
```

# Sex-linked markers

See @robledo_slm and @devloo_slm.

## Load data

### Bull Shark

```{r}
print(load("data/Bull_shark_DArTseq_genlight_for_Sex-linked_markers.Rdata"))
```

### Blue Shark

```{r}
print(load("data/Blue_shark_DArTseq_genlight_for_sex-linked_markers.Rdata"))
```

### Run `gl.filter.sexlinked`

![Markers on X and Y chromosomes](images/XY.png)

```{r, results="hold"}
res <- dartR.sexlinked::gl.filter.sexlinked(gl = data.gl, system = "xy", plots = TRUE, ncores = 1)
```

### Run `gl.infer.sex`

```{r}
sexID <- dartR.sexlinked::gl.infer.sex(gl_sex_filtered = res, system = "xy", seed = 124)
knitr::kable(head(sexID))
```


# Session information

```{r}
options(width = 100)
devtools::session_info()
```
